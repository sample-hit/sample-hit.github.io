<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance Luau Beautifier</title>
    <script src="https://cdn.jsdelivr.net/npm/luaparse@0.3.1/luaparse.min.js"></script>
    <style>
        :root { --bg: #0d1117; --accent: #58a6ff; --text: #c9d1d9; --panel: #161b22; }
        body { background-color: var(--bg); color: var(--text); font-family: 'Consolas', monospace; margin: 0; padding: 20px; overflow-x: hidden; }
        .container { max-width: 1200px; margin: auto; }
        .editor-box { display: flex; flex-direction: column; gap: 10px; }
        .status-bar { background: var(--panel); padding: 10px 20px; border: 1px solid #30363d; border-radius: 6px; display: flex; justify-content: space-between; font-size: 14px; }
        textarea {
            width: 100%; height: 400px; background: #010409; color: #7ee787;
            border: 1px solid #30363d; border-radius: 8px; padding: 15px;
            box-sizing: border-box; resize: vertical; outline: none; font-size: 14px;
            tab-size: 4;
        }
        .btn-row { margin: 20px 0; display: flex; gap: 12px; }
        button {
            padding: 12px 24px; background-color: #238636; color: white;
            border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        button:disabled { background-color: #1a4d23; cursor: not-allowed; opacity: 0.6; }
        button.sec { background-color: #30363d; }
        .progress-container { width: 100%; background: #000; height: 4px; border-radius: 2px; margin-top: 5px; display: none;}
        .progress-bar { width: 0%; height: 100%; background: var(--accent); transition: width 0.3s; }
    </style>
</head>
<body>

<div class="container">
    <h1>Advanced Luau Beautifier</h1>
    <p style="color: #8b949e;">Optimized for massive scripts (500k+ lines). Uses AST reconstruction.</p>

    <div class="editor-box">
        <div class="status-bar">
            <span id="char-count">Lines: 0 | Chars: 0</span>
            <span id="timer">Ready</span>
        </div>
        <textarea id="input" oninput="updateStats()" placeholder="-- Paste massive Luau script here..."></textarea>
        
        <div class="progress-container" id="prog-wrap"><div class="progress-bar" id="prog-bar"></div></div>

        <div class="btn-row">
            <button id="run-btn" onclick="beautifyLuau()">Format Script</button>
            <button class="sec" onclick="copyResult()">Copy Result</button>
            <button class="sec" onclick="downloadResult()">Download .lua</button>
        </div>

        <textarea id="output" readonly placeholder="Formatted output..."></textarea>
    </div>
</div>

<script>
    // Configuration
    const indentChar = "    "; // 4 spaces

    function updateStats() {
        const text = document.getElementById('input').value;
        const lines = text.split('\n').length;
        document.getElementById('char-count').innerText = `Lines: ${lines.toLocaleString()} | Chars: ${text.length.toLocaleString()}`;
    }

    async function beautifyLuau() {
        const input = document.getElementById('input').value;
        const outArea = document.getElementById('output');
        const btn = document.getElementById('run-btn');
        const timer = document.getElementById('timer');
        const progWrap = document.getElementById('prog-wrap');
        const progBar = document.getElementById('prog-bar');

        if (!input.trim()) return;

        // UI Feedback
        btn.disabled = true;
        btn.innerText = "Processing...";
        progWrap.style.display = "block";
        progBar.style.width = "20%";
        const start = performance.now();

        try {
            // Step 1: Parse the massive string into an AST
            // luaparse is fast, but 500k lines will take a moment
            const ast = luaparse.parse(input, { comments: true, luaVersion: 'LuaJIT' });
            progBar.style.width = "60%";

            // Step 2: AST to Clean Code Conversion
            // We use an array and join('') at the end to prevent string concatenation memory issues
            const formatted = formatNode(ast, 0);
            
            outArea.value = formatted;
            progBar.style.width = "100%";
            
            const totalTime = ((performance.now() - start) / 1000).toFixed(2);
            timer.innerText = `Finished in ${totalTime}s`;
        } catch (e) {
            alert("Luau Syntax Error: " + e.message);
            timer.innerText = "Error encountered.";
        } finally {
            btn.disabled = false;
            btn.innerText = "Format Script";
            setTimeout(() => { progWrap.style.display = "none"; }, 1000);
        }
    }

    function formatNode(node, indent) {
        const p = indentChar.repeat(indent);
        
        if (!node) return "";

        switch (node.type) {
            case 'Chunk':
                return node.body.map(n => formatNode(n, indent)).join('\n');

            case 'LocalStatement':
                const lNames = node.variables.map(v => v.name).join(', ');
                const lInits = node.init.map(i => formatNode(i, 0)).join(', ');
                return `${p}local ${lNames}${lInits ? ' = ' + lInits : ''}`;

            case 'AssignmentStatement':
                const aNames = node.variables.map(v => formatNode(v, 0)).join(', ');
                const aInits = node.init.map(i => formatNode(i, 0)).join(', ');
                return `${p}${aNames} = ${aInits}`;

            case 'CallStatement':
                return p + formatNode(node.expression, 0);

            case 'CallExpression':
                const base = formatNode(node.base, 0);
                const args = node.arguments.map(a => formatNode(a, 0)).join(', ');
                return `${base}(${args})`;

            case 'FunctionDeclaration':
                const fname = node.identifier ? formatNode(node.identifier, 0) : '';
                const params = node.parameters.map(param => param.name).join(', ');
                const body = node.body.map(n => formatNode(n, indent + 1)).join('\n');
                const isLocal = node.isLocal ? "local " : "";
                return `${p}${isLocal}function ${fname}(${params})\n${body}\n${p}end`;

            case 'IfStatement':
                let res = "";
                node.clauses.forEach((clause, i) => {
                    const block = clause.body.map(n => formatNode(n, indent + 1)).join('\n');
                    if (clause.type === 'IfClause') {
                        res += `${p}if ${formatNode(clause.condition, 0)} then\n${block}\n`;
                    } else if (clause.type === 'ElseifClause') {
                        res += `${p}elseif ${formatNode(clause.condition, 0)} then\n${block}\n`;
                    } else {
                        res += `${p}else\n${block}\n`;
                    }
                });
                return res + `${p}end`;

            case 'TableConstructorExpression':
                if (node.fields.length === 0) return "{}";
                const fields = node.fields.map(f => {
                    if (f.type === 'TableKeyString') return `[${formatNode(f.key, 0)}] = ${formatNode(f.value, 0)}`;
                    if (f.type === 'TableValue') return formatNode(f.value, 0);
                    return "";
                }).join(', ');
                return `{ ${fields} }`;

            case 'BinaryExpression':
            case 'LogicalExpression':
                return `${formatNode(node.left, 0)} ${node.operator} ${formatNode(node.right, 0)}`;

            case 'UnaryExpression':
                return `${node.operator}${formatNode(node.argument, 0)}`;

            case 'Identifier': return node.name;
            case 'StringLiteral': return `"${node.value}"`;
            case 'NumericLiteral': return node.value.toString();
            case 'BooleanLiteral': return node.value.toString();
            case 'NilLiteral': return "nil";
            case 'MemberExpression': return `${formatNode(node.base, 0)}${node.indexer}${formatNode(node.identifier, 0)}`;
            case 'IndexExpression': return `${formatNode(node.base, 0)}[${formatNode(node.index, 0)}]`;
            case 'ReturnStatement': return `${p}return ${node.arguments.map(a => formatNode(a, 0)).join(', ')}`;
            
            default: return "";
        }
    }

    function copyResult() {
        const out = document.getElementById('output');
        out.select();
        document.execCommand('copy');
    }

    function downloadResult() {
        const blob = new Blob([document.getElementById('output').value], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "beautified.lua";
        a.click();
    }
</script>

</body>
</html>
