<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Luau Virtualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/luaparse@0.3.1/luaparse.min.js"></script>
    <style>
        :root { --bg: #0d1117; --accent: #58a6ff; --text: #c9d1d9; --panel: #161b22; }
        body { background-color: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { width: 95%; max-width: 1100px; }
        .header-box { padding: 15px; background: var(--panel); border-radius: 8px 8px 0 0; border: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center;}
        textarea {
            width: 100%; height: 350px; background: #010409; color: #7ee787;
            border: 1px solid #30363d; border-radius: 0 0 8px 8px; padding: 15px;
            box-sizing: border-box; font-family: 'Consolas', monospace; resize: vertical; margin-bottom: 20px; outline: none;
        }
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            padding: 12px 24px; background-color: #238636; color: white;
            border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        button.sec { background-color: #30363d; }
        button:hover { opacity: 0.8; transform: translateY(-1px); }
        .logs { color: #8b949e; font-size: 13px; font-family: monospace; background: #000; padding: 10px; border-radius: 4px; border: 1px solid #333;}
    </style>
</head>
<body>

    <div class="container">
        <h1>Advanced Luau Virtualizer</h1>
        <p>Zero loadstring. Full AST Transformation & Constant Pooling.</p>

        <div class="header-box"><span>Source Luau</span></div>
        <textarea id="input" placeholder="print('Hello world!')"></textarea>

        <div class="btn-group">
            <button onclick="runObfuscator()">Obfuscate High Security</button>
            <button class="sec" onclick="copyCode()">Copy</button>
            <button class="sec" onclick="downloadFile()">Download</button>
        </div>

        <div class="header-box"><span>Obfuscated Result</span></div>
        <textarea id="output" readonly></textarea>
        <div id="logs" class="logs">Status: System Ready</div>
    </div>

<script>
    let constantPool = [];
    let varMap = {};

    // Generates unreadable variable names
    function generateId() {
        return "_0x" + Math.random().toString(16).slice(2, 8);
    }

    // Adds values to a pool so they aren't visible in the code directly
    function pool(val) {
        let index = constantPool.indexOf(val);
        if (index === -1) {
            constantPool.push(val);
            index = constantPool.length - 1;
        }
        return `_0xConst[${index}]`;
    }

    function runObfuscator() {
        const input = document.getElementById('input').value;
        const logs = document.getElementById('logs');
        const outputField = document.getElementById('output');
        
        constantPool = [];
        varMap = {};

        try {
            const ast = luaparse.parse(input);
            const startTime = performance.now();
            
            // Step 1: Process the code body
            let mainContent = processBlock(ast);
            
            // Step 2: Build the Virtualization Header
            let poolString = constantPool.map(v => {
                if (typeof v === 'string') {
                    return '"' + v.split('').map(c => '\\' + c.charCodeAt(0)).join('') + '"';
                }
                return v;
            }).join(', ');

            let finalHeader = `local _0xConst = {${poolString}}; local _0xVM = {CALL = function(f, ...) return f(...) end}; `;
            
            outputField.value = finalHeader + mainContent;
            logs.innerText = `Status: Success! Obfuscated in ${(performance.now() - startTime).toFixed(2)}ms`;
        } catch (e) {
            logs.innerText = "Error: " + e.message;
        }
    }

    function processBlock(block) {
        if (!block.body) return '';
        return block.body.map(node => unparse(node)).join('; ');
    }

    function unparse(node) {
        if (!node) return '';

        switch (node.type) {
            case 'LocalStatement':
                let lVars = node.variables.map(v => {
                    if (!varMap[v.name]) varMap[v.name] = generateId();
                    return varMap[v.name];
                }).join(', ');
                let lInits = node.init.map(i => unparse(i)).join(', ');
                return `local ${lVars} = ${lInits}`;

            case 'AssignmentStatement':
                let aVars = node.variables.map(v => unparse(v)).join(', ');
                let aInits = node.init.map(i => unparse(i)).join(', ');
                return `${aVars} = ${aInits}`;

            case 'CallStatement':
                return unparse(node.expression);

            case 'CallExpression':
                let base = unparse(node.base);
                let args = node.arguments.map(a => unparse(a)).join(', ');
                return `_0xVM.CALL(${base}${args ? ', ' + args : ''})`;

            case 'Identifier':
                // Check if it's a known local, otherwise treat as global and hide it
                if (varMap[node.name]) return varMap[node.name];
                return pool(node.name); 

            case 'StringLiteral':
            case 'NumericLiteral':
                return pool(node.value);

            case 'BooleanLiteral':
                return pool(node.value);

            case 'BinaryExpression':
            case 'LogicalExpression':
                return `(${unparse(node.left)} ${node.operator} ${unparse(node.right)})`;

            case 'UnaryExpression':
                return `(${node.operator}${unparse(node.argument)})`;

            case 'FunctionDeclaration':
                let name = node.identifier ? unparse(node.identifier) : '';
                let params = node.parameters.map(p => {
                    varMap[p.name] = generateId();
                    return varMap[p.name];
                }).join(', ');
                return `function ${name}(${params}) ${processBlock(node)} end`;

            case 'IfStatement':
                let clauses = node.clauses.map(clause => {
                    if (clause.type === 'IfClause') return `if ${unparse(clause.condition)} then ${processBlock(clause)}`;
                    if (clause.type === 'ElseifClause') return `elseif ${unparse(clause.condition)} then ${processBlock(clause)}`;
                    if (clause.type === 'ElseClause') return `else ${processBlock(clause)}`;
                });
                return clauses.join(' ') + " end";

            case 'TableConstructorExpression':
                let fields = node.fields.map(f => {
                    if (f.type === 'TableKeyString') return `[${unparse(f.key)}] = ${unparse(f.value)}`;
                    if (f.type === 'TableValue') return unparse(f.value);
                    return '';
                }).join(', ');
                return `{${fields}}`;

            case 'MemberExpression':
                return `${unparse(node.base)}${node.indexer}${unparse(node.identifier)}`;

            case 'IndexExpression':
                return `${unparse(node.base)}[${unparse(node.index)}]`;

            case 'ReturnStatement':
                return `return ${node.arguments.map(unparse).join(', ')}`;

            default:
                return '';
        }
    }

    function copyCode() {
        const out = document.getElementById('output');
        out.select();
        document.execCommand('copy');
    }

    function downloadFile() {
        const text = document.getElementById('output').value;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.download = "obfuscated.txt";
        a.href = URL.createObjectURL(blob);
        a.click();
    }
</script>
</body>
</html>
