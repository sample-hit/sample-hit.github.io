<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luau Virtual-Unparser</title>
    <script src="https://cdn.jsdelivr.net/npm/luaparse@0.3.1/luaparse.min.js"></script>
    <style>
        :root { --bg: #0d1117; --accent: #58a6ff; --text: #c9d1d9; --panel: #161b22; }
        body { background-color: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { width: 95%; max-width: 1100px; }
        .header-box { padding: 15px; background: var(--panel); border-radius: 8px 8px 0 0; border: 1px solid #30363d; display: flex; justify-content: space-between; align-items: center;}
        textarea {
            width: 100%; height: 350px; background: #010409; color: #7ee787;
            border: 1px solid #30363d; border-radius: 0 0 8px 8px; padding: 15px;
            box-sizing: border-box; font-family: 'Consolas', monospace; resize: vertical; margin-bottom: 20px; outline: none;
        }
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            padding: 12px 24px; background-color: #238636; color: white;
            border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        button.sec { background-color: #30363d; }
        button:hover { opacity: 0.8; transform: translateY(-1px); }
        .logs { color: #8b949e; font-size: 13px; font-family: monospace; background: #000; padding: 10px; border-radius: 4px; border: 1px solid #333;}
    </style>
</head>
<body>

    <div class="container">
        <h1>LuaU Web Obfuscator</h1>
        <p>A port of the Luau AST Unparser to JavaScript for web deployment.</p>

        <div class="header-box"><span>Source Code (Luau)</span></div>
        <textarea id="input" placeholder="print('Hello World')"></textarea>

        <div class="btn-group">
            <button onclick="runObfuscator()">Obfuscate Code</button>
            <button class="sec" onclick="copyCode()">Copy to Clipboard</button>
            <button class="sec" onclick="downloadFile()">Download .txt</button>
        </div>

        <div class="header-box"><span>Obfuscated Result</span></div>
        <textarea id="output" readonly></textarea>
        <div id="logs" class="logs">Status: Waiting for input...</div>
    </div>

<script>
    // Header mimics the 'callId' and 'constantCollection' logic from your script
    const HEADER = `--[[ Protected by Gemini-Unparser v2 ]]\nlocal _VM = {CALL = function(f, ...) return f(...) end, GET = function(v) return v end}\n`;

    function runObfuscator() {
        const input = document.getElementById('input').value;
        const logs = document.getElementById('logs');
        const outputField = document.getElementById('output');

        if (!input.trim()) {
            logs.innerText = "Error: Input is empty.";
            return;
        }

        try {
            const ast = luaparse.parse(input);
            const startTime = performance.now();
            
            // Rebuilding the script node by node
            let result = HEADER + processBlock(ast);
            
            outputField.value = result;
            const time = (performance.now() - startTime).toFixed(2);
            logs.innerText = `Status: Success! Time: ${time}ms | Size: ${(result.length / 1024).toFixed(2)} kb`;
        } catch (e) {
            logs.innerText = "Syntax Error: " + e.message;
            console.error(e);
        }
    }

    function processBlock(block) {
        if (!block.body) return '';
        return block.body.map(node => unparse(node)).join('; ');
    }

    function unparse(node) {
        if (!node) return '';

        switch (node.type) {
            case 'LocalStatement':
                let lVars = node.variables.map(v => v.name).join(', ');
                let lInits = node.init.map(i => unparse(i)).join(', ');
                return `local ${lVars} = ${lInits}`;

            case 'AssignmentStatement':
                let aVars = node.variables.map(v => unparse(v)).join(', ');
                let aInits = node.init.map(i => unparse(i)).join(', ');
                return `${aVars} = ${aInits}`;

            case 'CallStatement':
                return unparse(node.expression);

            case 'CallExpression':
                let base = unparse(node.base);
                let args = node.arguments.map(a => unparse(a)).join(', ');
                return `_VM.CALL(${base}${args ? ', ' + args : ''})`;

            case 'Identifier':
                return node.name;

            case 'StringLiteral':
                // FIXED: Now safely converts string values to Hex/Escape codes
                let strVal = node.value || "";
                let hex = strVal.split('').map(c => '\\' + c.charCodeAt(0)).join('');
                return `_VM.GET("${hex}")`;

            case 'NumericLiteral':
                return node.value;

            case 'BooleanLiteral':
                return node.value.toString();

            case 'NilLiteral':
                return 'nil';

            case 'BinaryExpression':
            case 'LogicalExpression':
                return `(${unparse(node.left)} ${node.operator} ${unparse(node.right)})`;

            case 'UnaryExpression':
                return `(${node.operator}${unparse(node.argument)})`;

            case 'FunctionDeclaration':
                let name = node.identifier ? unparse(node.identifier) : '';
                let params = node.parameters.map(p => p.name).join(', ');
                return `function ${name}(${params}) ${processBlock(node)} end`;

            case 'IfStatement':
                let clauses = node.clauses.map((clause, index) => {
                    if (clause.type === 'IfClause') return `if ${unparse(clause.condition)} then ${processBlock(clause)}`;
                    if (clause.type === 'ElseifClause') return `elseif ${unparse(clause.condition)} then ${processBlock(clause)}`;
                    if (clause.type === 'ElseClause') return `else ${processBlock(clause)}`;
                });
                return clauses.join(' ') + " end";

            case 'TableConstructorExpression':
                let fields = node.fields.map(f => {
                    if (f.type === 'TableKeyString') return `[${unparse(f.key)}] = ${unparse(f.value)}`;
                    if (f.type === 'TableKey') return `[${unparse(f.key)}] = ${unparse(f.value)}`;
                    if (f.type === 'TableValue') return unparse(f.value);
                    return '';
                }).join(', ');
                return `{${fields}}`;

            case 'MemberExpression':
                return `${unparse(node.base)}${node.indexer}${unparse(node.identifier)}`;

            case 'IndexExpression':
                return `${unparse(node.base)}[${unparse(node.index)}]`;

            case 'ReturnStatement':
                return `return ${node.arguments.map(unparse).join(', ')}`;

            default:
                return `--[[ Node ${node.type} not fully supported yet ]]`;
        }
    }

    function copyCode() {
        const out = document.getElementById('output');
        if (!out.value) return;
        out.select();
        document.execCommand('copy');
        document.getElementById('logs').innerText = "Status: Copied to clipboard!";
    }

    function downloadFile() {
        const text = document.getElementById('output').value;
        if (!text) return;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.download = "obfuscated_script.txt";
        a.href = URL.createObjectURL(blob);
        a.click();
    }
</script>
</body>
</html>
