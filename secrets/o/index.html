<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enterprise Luau Formatter</title>
    <script src="https://cdn.jsdelivr.net/npm/luaparse@0.3.1/luaparse.min.js"></script>
    <style>
        :root { --bg: #0d1117; --accent: #58a6ff; --text: #c9d1d9; --panel: #161b22; }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', monospace; margin: 0; padding: 20px; }
        .wrapper { max-width: 1200px; margin: auto; display: flex; flex-direction: column; gap: 15px; }
        textarea {
            width: 100%; height: 350px; background: #010409; color: #d7dae0;
            border: 1px solid #30363d; border-radius: 8px; padding: 15px;
            font-family: 'Consolas', 'Courier New', monospace; font-size: 13px;
            tab-size: 4; outline: none;
        }
        .bar { background: var(--panel); padding: 12px; border: 1px solid #30363d; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; }
        .btns { display: flex; gap: 10px; }
        button {
            padding: 10px 20px; background: #238636; color: white; border: none;
            border-radius: 6px; font-weight: 600; cursor: pointer;
        }
        button:hover { background: #2ea043; }
        .sec { background: #30363d; }
        #status { font-size: 13px; color: var(--accent); }
    </style>
</head>
<body>

<div class="wrapper">
    <h1>Luau AST Beautifier v3</h1>
    
    <div class="bar">
        <span id="status">Ready for processing...</span>
        <div class="btns">
            <button onclick="beautify()">Format All Code</button>
            <button class="sec" onclick="copyText()">Copy</button>
            <button class="sec" onclick="download()">Download</button>
        </div>
    </div>

    <textarea id="input" placeholder="Paste your Luau script here..."></textarea>
    <textarea id="output" readonly placeholder="Output will appear here..."></textarea>
</div>

<script>
    const tab = "    ";

    function beautify() {
        const input = document.getElementById('input').value;
        const out = document.getElementById('output');
        const status = document.getElementById('status');
        
        if (!input) return;
        status.innerText = "Parsing AST...";

        try {
            // We use LuaJIT mode to support as many Luau features as possible
            const ast = luaparse.parse(input, { wait: false, scope: true });
            status.innerText = "Reconstructing Source...";
            
            const result = unparse(ast, 0);
            out.value = result;
            status.innerText = "Success: Formatted " + out.value.split('\n').length + " lines.";
        } catch (e) {
            status.innerText = "Error: " + e.message;
            console.error(e);
        }
    }

    function unparse(node, depth) {
        if (!node) return "";
        const indent = tab.repeat(depth);

        switch (node.type) {
            case 'Chunk':
                return node.body.map(st => unparse(st, depth)).join('\n');

            case 'LocalStatement':
                let lVars = node.variables.map(v => v.name).join(', ');
                let lInits = node.init.length > 0 ? " = " + node.init.map(i => unparse(i, 0)).join(', ') : "";
                return `${indent}local ${lVars}${lInits}`;

            case 'AssignmentStatement':
                let aVars = node.variables.map(v => unparse(v, 0)).join(', ');
                let aInits = node.init.map(i => unparse(i, 0)).join(', ');
                return `${indent}${aVars} = ${aInits}`;

            case 'CallStatement':
                return indent + unparse(node.expression, 0);

            case 'CallExpression':
                return `${unparse(node.base, 0)}(${node.arguments.map(a => unparse(a, 0)).join(', ')})`;

            case 'StringCallExpression':
                return `${unparse(node.base, 0)} ${unparse(node.argument, 0)}`;

            case 'TableCallExpression':
                return `${unparse(node.base, 0)}${unparse(node.arguments, 0)}`;

            case 'FunctionDeclaration':
                let fName = node.identifier ? unparse(node.identifier, 0) : "";
                let fParams = node.parameters.map(p => p.type === 'VarargLiteral' ? "..." : p.name).join(', ');
                let fBody = node.body.map(st => unparse(st, depth + 1)).join('\n');
                let prefix = node.isLocal ? "local " : "";
                return `${indent}${prefix}function ${fName}(${fParams})\n${fBody}\n${indent}end`;

            case 'IfStatement':
                let text = "";
                node.clauses.forEach((c, i) => {
                    let cBody = c.body.map(st => unparse(st, depth + 1)).join('\n');
                    if (c.type === 'IfClause') {
                        text += `${indent}if ${unparse(c.condition, 0)} then\n${cBody}\n`;
                    } else if (c.type === 'ElseifClause') {
                        text += `${indent}elseif ${unparse(c.condition, 0)} then\n${cBody}\n`;
                    } else if (c.type === 'ElseClause') {
                        text += `${indent}else\n${cBody}\n`;
                    }
                });
                return text + `${indent}end`;

            case 'WhileStatement':
                return `${indent}while ${unparse(node.condition, 0)} do\n${node.body.map(st => unparse(st, depth + 1)).join('\n')}\n${indent}end`;

            case 'DoStatement':
                return `${indent}do\n${node.body.map(st => unparse(st, depth + 1)).join('\n')}\n${indent}end`;

            case 'ReturnStatement':
                return `${indent}return ${node.arguments.map(a => unparse(a, 0)).join(', ')}`;

            case 'BreakStatement': return indent + "break";

            case 'ForNumericStatement':
                let start = unparse(node.start, 0);
                let end = unparse(node.end, 0);
                let step = node.step ? ", " + unparse(node.step, 0) : "";
                return `${indent}for ${node.variable.name} = ${start}, ${end}${step} do\n${node.body.map(st => unparse(st, depth + 1)).join('\n')}\n${indent}end`;

            case 'ForGenericStatement':
                let gVars = node.variables.map(v => v.name).join(', ');
                let gInits = node.iterators.map(i => unparse(i, 0)).join(', ');
                return `${indent}for ${gVars} in ${gInits} do\n${node.body.map(st => unparse(st, depth + 1)).join('\n')}\n${indent}end`;

            case 'TableConstructorExpression':
                if (node.fields.length === 0) return "{}";
                let fields = node.fields.map(f => {
                    if (f.type === 'TableKey') return `[${unparse(f.key, 0)}] = ${unparse(f.value, 0)}`;
                    if (f.type === 'TableKeyString') return `${f.key.name} = ${unparse(f.value, 0)}`;
                    return unparse(f.value, 0);
                }).join(', ');
                return `{ ${fields} }`;

            case 'BinaryExpression':
            case 'LogicalExpression':
                return `(${unparse(node.left, 0)} ${node.operator} ${unparse(node.right, 0)})`;

            case 'UnaryExpression':
                return `${node.operator}${unparse(node.argument, 0)}`;

            case 'MemberExpression':
                return `${unparse(node.base, 0)}${node.indexer}${unparse(node.identifier, 0)}`;

            case 'IndexExpression':
                return `${unparse(node.base)}[${unparse(node.index, 0)}]`;

            case 'Identifier': return node.name;
            case 'StringLiteral': return `"${node.value}"`;
            case 'NumericLiteral': return node.value.toString();
            case 'BooleanLiteral': return node.value.toString();
            case 'NilLiteral': return "nil";
            case 'VarargLiteral': return "...";

            default:
                console.warn("Unhandled:", node.type);
                return "";
        }
    }

    function copyText() {
        document.getElementById('output').select();
        document.execCommand('copy');
    }

    function download() {
        const text = document.getElementById('output').value;
        const blob = new Blob([text], {type: 'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "beautified.lua";
        a.click();
    }
</script>
</body>
</html>
