<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luau Virtual-Unparser</title>
    <script src="https://cdn.jsdelivr.net/npm/luaparse@0.3.1/luaparse.min.js"></script>
    <style>
        :root { --bg: #0d1117; --accent: #58a6ff; --text: #c9d1d9; --panel: #161b22; }
        body { background-color: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { width: 95%; max-width: 1100px; }
        .header-box { padding: 15px; background: var(--panel); border-radius: 8px 8px 0 0; border: 1px solid #30363d; display: flex; justify-content: space-between; }
        textarea {
            width: 100%; height: 350px; background: #010409; color: #7ee787;
            border: 1px solid #30363d; border-radius: 0 0 8px 8px; padding: 15px;
            box-sizing: border-box; font-family: 'Consolas', monospace; resize: vertical; margin-bottom: 20px;
        }
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button {
            padding: 12px 24px; background-color: #238636; color: white;
            border: none; border-radius: 6px; cursor: pointer; font-weight: bold;
        }
        button.sec { background-color: #30363d; }
        button:hover { opacity: 0.8; }
        .logs { color: #8b949e; font-size: 13px; font-family: monospace; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Luau Web Obfuscator</h1>
        <p>A port of the Luau AST Unparser to JavaScript.</p>

        <div class="header-box"><span>Source Code</span></div>
        <textarea id="input" placeholder="print('Hello World')"></textarea>

        <div class="btn-group">
            <button onclick="runObfuscator()">Obfuscate Code</button>
            <button class="sec" onclick="copyCode()">Copy</button>
            <button class="sec" onclick="downloadFile()">Download .txt</button>
        </div>

        <div class="header-box"><span>Obfuscated Result</span></div>
        <textarea id="output" readonly></textarea>
        <div id="logs" class="logs"></div>
    </div>



<script>
    // This replicates the "callFormat" and VM structure of your Luau script
    const HEADER = `-- Protected by WebUnparser\nlocal _CHECK = {CALL = function(f, ...) return f(...) end, GET = function(v) return v end}\n`;

    function runObfuscator() {
        const input = document.getElementById('input').value;
        const logs = document.getElementById('logs');
        const outputField = document.getElementById('output');

        try {
            const ast = luaparse.parse(input);
            const startTime = performance.now();
            
            // Rebuilding the script node by node
            let result = HEADER + processBlock(ast);
            
            outputField.value = result;
            const time = (performance.now() - startTime).toFixed(2);
            logs.innerText = `Finished in ${time}ms. Size: ${(result.length / 1024).toFixed(2)} kb`;
        } catch (e) {
            logs.innerText = "Error: " + e.message;
        }
    }

    function processBlock(block) {
        return block.body.map(node => unparse(node)).join('; ');
    }

    function unparse(node) {
        if (!node) return '';

        switch (node.type) {
            case 'LocalStatement':
                let lVars = node.variables.map(v => v.name).join(', ');
                let lInits = node.init.map(i => unparse(i)).join(', ');
                return `local ${lVars} = ${lInits}`;

            case 'AssignmentStatement':
                let aVars = node.variables.map(v => unparse(v)).join(', ');
                let aInits = node.init.map(i => unparse(i)).join(', ');
                return `${aVars} = ${aInits}`;

            case 'CallStatement':
                return unparse(node.expression);

            case 'CallExpression':
                let base = unparse(node.base);
                let args = node.arguments.map(a => unparse(a)).join(', ');
                return `_CHECK.CALL(${base}${args ? ', ' + args : ''})`;

            case 'Identifier':
                return node.name;

            case 'StringLiteral':
                // Convert string to hex escape codes (\104\101...)
                let hex = node.value.split('').map(c => '\\' + c.charCodeAt(0)).join('');
                return `_CHECK.GET("${hex}")`;

            case 'NumericLiteral':
                return node.value;

            case 'BooleanLiteral':
                return node.value.toString();

            case 'NilLiteral':
                return 'nil';

            case 'BinaryExpression':
                return `(${unparse(node.left)} ${node.operator} ${unparse(node.right)})`;

            case 'UnaryExpression':
                return `(${node.operator}${unparse(node.argument)})`;

            case 'FunctionDeclaration':
                let name = node.identifier ? unparse(node.identifier) : '';
                let params = node.parameters.map(p => p.name).join(', ');
                return `function ${name}(${params}) ${processBlock(node)} end`;

            case 'IfStatement':
                let code = `if ${unparse(node.clauses[0].condition)} then ${processBlock(node.clauses[0])} `;
                for (let i = 1; i < node.clauses.length; i++) {
                    let clause = node.clauses[i];
                    if (clause.type === 'ElseifClause') {
                        code += `elseif ${unparse(clause.condition)} then ${processBlock(clause)} `;
                    } else if (clause.type === 'ElseClause') {
                        code += `else ${processBlock(clause)} `;
                    }
                }
                return code + "end";

            case 'TableConstructorExpression':
                let fields = node.fields.map(f => {
                    if (f.type === 'TableKeyString') return `[${unparse(f.key)}] = ${unparse(f.value)}`;
                    if (f.type === 'TableValue') return unparse(f.value);
                    return '';
                }).join(', ');
                return `{${fields}}`;

            case 'MemberExpression':
                return `${unparse(node.base)}${node.indexer}${unparse(node.identifier)}`;

            case 'IndexExpression':
                return `${unparse(node.base)}[${unparse(node.index)}]`;

            default:
                console.log("Unhandled Node:", node.type);
                return '';
        }
    }

    function copyCode() {
        const out = document.getElementById('output');
        out.select();
        document.execCommand('copy');
        alert("Copied!");
    }

    function downloadFile() {
        const text = document.getElementById('output').value;
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.download = "obfuscated_script.txt";
        a.href = URL.createObjectURL(blob);
        a.click();
    }
</script>
</body>
</html>
